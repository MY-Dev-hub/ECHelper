# 프론트엔드와 백엔드 완전 기초 가이드

> **대상**: 웹 개발 경험이 전혀 없는 분들을 위한 가이드
> **목표**: 왜 프론트엔드와 백엔드를 나누는지, 각각이 무엇인지 완벽히 이해하기

---

## 📚 목차
1. [웹사이트는 어떻게 작동하나요?](#1-웹사이트는-어떻게-작동하나요)
2. [프론트엔드란 무엇인가요?](#2-프론트엔드란-무엇인가요)
3. [백엔드란 무엇인가요?](#3-백엔드란-무엇인가요)
4. [왜 둘로 나누나요?](#4-왜-둘로-나누나요)
5. [어떻게 통신하나요?](#5-어떻게-통신하나요)
6. [개발 환경 vs 실제 서버](#6-개발-환경-vs-실제-서버)
7. [ECHelper 프로젝트 구조](#7-echelper-프로젝트-구조)

---

## 1. 웹사이트는 어떻게 작동하나요?

### 🏪 레스토랑 비유로 이해하기

웹사이트를 **레스토랑**이라고 생각해봅시다:

```
고객(사용자) → 홀(프론트엔드) → 주방(백엔드) → 재료창고(데이터베이스)
```

#### 레스토랑에서 일어나는 일:

1. **고객이 들어옴** (브라우저 접속)
   - "어서오세요!" → 웹사이트가 열림

2. **메뉴판을 봄** (프론트엔드)
   - 예쁜 디자인, 사진, 설명
   - 주문 버튼

3. **주문함** (API 요청)
   - "불고기 정식 하나요!"
   - 홀 직원이 주방에 전달

4. **주방에서 요리** (백엔드 처리)
   - 재료 가져오기 (데이터베이스 조회)
   - 요리하기 (AI 모델 실행, 계산 등)

5. **음식 서빙** (응답)
   - 완성된 요리를 고객에게
   - 결과를 화면에 표시

### 💻 실제 웹사이트 예시

**네이버에서 검색할 때:**

```
1. 검색창에 "날씨" 입력 → 프론트엔드 (화면)
2. 엔터 누르면 → 백엔드에 요청 전송
3. 백엔드가 날씨 정보 가져옴 → 데이터베이스/API 조회
4. 결과를 다시 전송 → 프론트엔드로
5. 화면에 날씨 표시 → 프론트엔드가 렌더링
```

---

## 2. 프론트엔드란 무엇인가요?

### 📱 정의
> **프론트엔드 = 사용자가 직접 보고 만지는 모든 것**

### 구성 요소

#### 1. **HTML** (구조)
집의 뼈대 (벽, 문, 창문)
```html
<button>클릭하세요</button>
<input placeholder="검색어 입력">
```

#### 2. **CSS** (디자인)
집의 인테리어 (색상, 크기, 위치)
```css
button {
  color: blue;
  font-size: 20px;
}
```

#### 3. **JavaScript** (동작)
집의 전기/수도 시스템 (동적 기능)
```javascript
button.onClick = () => {
  alert("클릭됨!");
}
```

### 🎯 프론트엔드가 하는 일

| 할 수 있는 것 | 할 수 없는 것 |
|--------------|--------------|
| ✅ 버튼 보여주기 | ❌ 데이터베이스 접근 |
| ✅ 입력받기 | ❌ 파일 시스템 접근 |
| ✅ 예쁘게 꾸미기 | ❌ Python 코드 실행 |
| ✅ 간단한 계산 | ❌ AI 모델 실행 |
| ✅ 애니메이션 | ❌ 무거운 연산 |

### 📦 프론트엔드 기술 스택 (ECHelper 기준)

```
React (UI 라이브러리)
  ↓
TypeScript (타입 안전 JavaScript)
  ↓
Vite (빌드 도구)
  ↓
Ant Design (UI 컴포넌트)
```

**왜 React?**
- 재사용 가능한 컴포넌트
- 빠른 렌더링
- 큰 커뮤니티

---

## 3. 백엔드란 무엇인가요?

### 🏭 정의
> **백엔드 = 사용자가 보지 못하는 서버 측 로직**

### 🔧 백엔드가 하는 일

#### 1. **데이터 처리**
```python
# 사용자 입력: "레이저 거리측정기"
# 백엔드: AI 모델로 분석
result = model.predict("레이저 거리측정기")
# 결과: {"isStrategic": false, "confidence": 60.3}
```

#### 2. **데이터베이스 관리**
```python
# 과거 이력 조회
history = database.query("SELECT * FROM export_history")
```

#### 3. **비즈니스 로직**
```python
# 전략물자 판단 기준
if confidence > 0.5:
    return "전략물자"
else:
    return "비전략물자"
```

#### 4. **외부 API 호출**
```python
# 환율 정보 가져오기
exchange_rate = external_api.get_usd_rate()
```

### 🎯 백엔드가 하는 일

| 할 수 있는 것 | 할 수 없는 것 |
|--------------|--------------|
| ✅ AI 모델 실행 | ❌ 화면에 직접 표시 |
| ✅ 데이터베이스 조작 | ❌ 사용자 입력 받기 |
| ✅ 복잡한 연산 | ❌ 버튼 클릭 감지 |
| ✅ 파일 읽기/쓰기 | ❌ CSS 스타일링 |
| ✅ 보안 처리 | ❌ 애니메이션 |

### 📦 백엔드 기술 스택 (ECHelper 기준)

```
FastAPI (웹 프레임워크)
  ↓
PyTorch (AI 모델)
  ↓
Transformers (KoBERT)
  ↓
Uvicorn (서버)
```

**왜 FastAPI?**
- 빠른 성능
- 자동 API 문서
- Python 네이티브

---

## 4. 왜 둘로 나누나요?

### 🤔 "하나로 합치면 안 되나요?"

이론적으로는 가능하지만, **여러 이유로 분리합니다**:

### 이유 1: **기술적 제약**

#### 브라우저의 한계
```
브라우저에서 할 수 있는 것:
✅ HTML 렌더링
✅ CSS 스타일링
✅ JavaScript 실행

브라우저에서 할 수 없는 것:
❌ Python 실행
❌ 시스템 파일 접근
❌ 네이티브 라이브러리 사용
```

**예시:**
```python
# 이 코드는 브라우저에서 못 돌림!
import torch
model = torch.load('model.pth')
```

### 이유 2: **보안**

#### 민감한 정보 보호
```
프론트엔드 (브라우저):
- 모든 코드가 사용자에게 노출됨
- 개발자 도구로 다 볼 수 있음
- 조작 가능

백엔드 (서버):
- 코드가 서버에만 존재
- 사용자가 볼 수 없음
- 안전하게 보호됨
```

**예시:**
```python
# 백엔드에만 있어야 하는 것들
DATABASE_PASSWORD = "secret123"  # 노출되면 안됨!
API_KEY = "sk-abc123xyz"         # 돈이 나갈 수 있음!
```

### 이유 3: **성능**

#### 무거운 작업은 서버에서
```
프론트엔드 (브라우저):
- 사용자 컴퓨터에서 실행
- 느린 컴퓨터면 느려짐
- 메모리 제한 있음

백엔드 (서버):
- 강력한 서버 컴퓨터
- GPU 사용 가능
- 무제한 메모리
```

**예시:**
```
KoBERT 모델 (352MB):
❌ 브라우저: 다운로드만 5분, 실행 느림
✅ 서버: 한 번 로드, 빠른 실행
```

### 이유 4: **개발 효율**

#### 전문화 & 협업
```
프론트엔드 개발자:
- UI/UX 전문
- JavaScript/React 전문
- 디자인 감각

백엔드 개발자:
- 서버/DB 전문
- Python/Java 전문
- 알고리즘/성능 최적화

각자 전문 분야에 집중!
```

### 이유 5: **유지보수**

#### 독립적 수정 가능
```
프론트엔드 수정:
- 버튼 색깔 변경
- 레이아웃 조정
→ 백엔드는 그대로

백엔드 수정:
- AI 모델 업데이트
- 데이터베이스 변경
→ 프론트엔드는 그대로
```

---

## 5. 어떻게 통신하나요?

### 📡 HTTP 프로토콜

#### 우체국 시스템과 비슷합니다

```
프론트엔드 → [편지] → 백엔드
             ↓
         HTTP 요청
             ↓
백엔드 → [답장] → 프론트엔드
             ↓
         HTTP 응답
```

### 실제 예시: ECHelper 예측 요청

#### 1단계: 프론트엔드에서 요청
```typescript
// frontend/src/services/kobertPrediction.ts

const response = await fetch('http://localhost:8000/predict', {
  method: 'POST',                    // 편지 종류: POST
  headers: {
    'Content-Type': 'application/json'  // 편지 형식: JSON
  },
  body: JSON.stringify({             // 편지 내용
    text: "레이저 거리측정기"
  })
});
```

**보내는 내용:**
```
POST /predict HTTP/1.1
Host: localhost:8000
Content-Type: application/json

{"text": "레이저 거리측정기"}
```

#### 2단계: 백엔드에서 받음
```python
# backend/app.py

@app.post("/predict")
def predict(request: PredictRequest):
    text = request.text  # "레이저 거리측정기"

    # AI 모델 실행
    result = model.predict(text)

    return result
```

#### 3단계: 백엔드에서 응답
```python
# 응답 내용
{
  "isStrategic": false,
  "confidence": 60.3,
  "eccn": "N/A",
  "classType": "N/A",
  "explanation": "일반 상업용 품목으로 판단됩니다."
}
```

#### 4단계: 프론트엔드에서 받아서 화면에 표시
```typescript
const result = await response.json();

// 화면에 표시
setResult(result);
```

### 📊 통신 과정 시각화

```
사용자 행동:
"레이저 거리측정기" 입력 → 버튼 클릭

     ↓

프론트엔드:
입력값 수집 → JSON으로 변환 → HTTP POST 요청

     ↓ (인터넷 통신)

백엔드:
요청 받음 → 데이터 추출 → AI 모델 실행 → 결과 생성

     ↓ (인터넷 통신)

프론트엔드:
응답 받음 → JSON 파싱 → 화면에 렌더링

     ↓

사용자:
결과 확인 "비전략물자 60.3%"
```

### 🔑 핵심 개념: API (Application Programming Interface)

#### API란?
> **프론트엔드와 백엔드가 약속한 통신 규칙**

**식당 예시:**
```
메뉴판 = API 문서

"불고기 정식 주문하기"
- 주문 방법: 직원에게 말하기
- 필요한 정보: "불고기 정식 1개"
- 받는 것: 불고기 정식
- 시간: 15분
```

**ECHelper API:**
```
"/predict 엔드포인트"
- 요청 방법: POST
- 필요한 정보: {"text": "품목명"}
- 받는 것: {"isStrategic": bool, "confidence": number, ...}
- 시간: 1-2초
```

---

## 6. 개발 환경 vs 실제 서버

### 🏗️ 개발 환경 (지금 상태)

#### 구조
```
내 컴퓨터 (localhost)
├── 백엔드: localhost:8000
│   └── Python 서버 (Uvicorn)
└── 프론트엔드: localhost:5173
    └── Vite 개발 서버

둘 다 내 컴퓨터에서 실행!
```

#### 특징
```
✅ 빠른 개발
✅ 코드 수정 즉시 반영 (Hot Reload)
✅ 디버깅 편함
✅ 무료

❌ 나만 접속 가능
❌ 인터넷에서 접근 불가
❌ 컴퓨터 끄면 중단
```

#### 실행 방법
```bash
# 터미널 1
cd backend
python -m uvicorn app:app --reload

# 터미널 2
cd frontend
npm run dev
```

### 🌐 실제 서버 (Production)

#### 구조
```
클라우드 서버 (AWS/Azure/GCP)
├── 백엔드: api.echelper.com
│   └── Docker 컨테이너
│   └── Nginx 리버스 프록시
│   └── 24시간 가동
└── 프론트엔드: www.echelper.com
    └── 빌드된 정적 파일 (HTML/CSS/JS)
    └── CDN으로 배포

전 세계 어디서나 접속 가능!
```

#### 특징
```
✅ 24시간 가동
✅ 누구나 접속 가능
✅ 빠른 속도 (CDN)
✅ 자동 확장 (Auto Scaling)

❌ 비용 발생
❌ 설정 복잡
❌ 보안 관리 필요
```

#### 배포 과정

**백엔드 배포:**
```bash
# 1. Docker 이미지 생성
docker build -t echelper-backend .

# 2. AWS에 업로드
docker push echelper-backend

# 3. EC2 서버에서 실행
docker run -d -p 80:8000 echelper-backend

# 4. 도메인 연결
api.echelper.com → EC2 IP 주소
```

**프론트엔드 배포:**
```bash
# 1. 빌드 (정적 파일 생성)
npm run build
# 결과: dist/ 폴더에 HTML/CSS/JS

# 2. S3/Netlify/Vercel 업로드
aws s3 sync dist/ s3://echelper-frontend

# 3. CloudFront CDN 설정
www.echelper.com → CloudFront → S3
```

### 📊 비교표

| 항목 | 개발 환경 | 실제 서버 |
|------|----------|----------|
| **접속** | localhost만 | 전 세계 |
| **비용** | 무료 | 월 $50~500 |
| **속도** | 보통 | 매우 빠름 |
| **안정성** | 컴퓨터 끄면 중단 | 24시간 가동 |
| **보안** | 불필요 | HTTPS, 방화벽 필수 |
| **확장성** | 1명만 | 동시 수천 명 |

---

## 7. ECHelper 프로젝트 구조

### 📁 전체 폴더 구조

```
C:\Users\user-\Desktop\ECHelper\
│
├── frontend/                    # 프론트엔드 (React)
│   ├── src/
│   │   ├── components/         # UI 컴포넌트
│   │   │   ├── prediction/
│   │   │   │   ├── PredictionForm.tsx      # 입력 폼
│   │   │   │   ├── PredictionResult.tsx    # 결과 표시
│   │   │   │   └── SimilarCasesList.tsx    # 유사 사례
│   │   ├── pages/              # 페이지
│   │   │   ├── PredictionPage.tsx          # 예측 페이지
│   │   │   └── SettingsPage.tsx            # 설정 페이지
│   │   ├── services/           # API 호출
│   │   │   └── kobertPrediction.ts         # 백엔드 API 호출
│   │   └── utils/              # 유틸리티
│   │       └── tfidf.ts                    # 유사도 계산
│   ├── public/                 # 정적 파일
│   │   ├── data/
│   │   │   └── export_history.json         # 과거 이력 데이터
│   │   └── models/
│   │       └── kobert-onnx/
│   │           └── model_info.json         # 모델 정보
│   ├── package.json            # 의존성 관리
│   └── vite.config.ts          # Vite 설정
│
├── backend/                     # 백엔드 (FastAPI)
│   ├── app.py                  # 메인 서버 파일
│   └── test_api.py             # API 테스트
│
├── scripts/                     # 학습 스크립트
│   ├── train_kobert.py         # 모델 학습
│   └── evaluate_model_simple.py # 모델 평가
│
├── models/                      # 저장된 모델
│   └── kobert-strategic-final/
│       ├── model.safetensors   # 학습된 모델 가중치
│       ├── config.json         # 모델 설정
│       └── tokenizer.json      # 토크나이저
│
└── data/                        # 학습 데이터
    └── export_history.json     # 전략물자 이력
```

### 🔄 데이터 흐름도

```
┌─────────────────────────────────────────────────────────────┐
│                       사용자 (브라우저)                        │
└────────────────────────┬────────────────────────────────────┘
                         │
                         │ http://localhost:5173
                         ↓
┌─────────────────────────────────────────────────────────────┐
│                    프론트엔드 (React)                          │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ PredictionPage.tsx                                   │   │
│  │  - 사용자 입력 받기                                    │   │
│  │  - API 호출 트리거                                     │   │
│  └──────────┬──────────────────────────────────────────┘   │
│             │                                                │
│             ↓                                                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ kobertPrediction.ts                                  │   │
│  │  - fetch('http://localhost:8000/predict')           │   │
│  │  - POST {"text": "레이저 거리측정기"}                  │   │
│  └──────────┬──────────────────────────────────────────┘   │
└─────────────┼───────────────────────────────────────────────┘
              │
              │ HTTP POST
              │ {"text": "레이저 거리측정기"}
              ↓
┌─────────────────────────────────────────────────────────────┐
│                    백엔드 (FastAPI)                           │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ app.py                                               │   │
│  │                                                      │   │
│  │  @app.post("/predict")                              │   │
│  │  def predict(request):                              │   │
│  └──────────┬──────────────────────────────────────────┘   │
│             │                                                │
│             ↓                                                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 1. 토크나이징                                          │   │
│  │    inputs = tokenizer("레이저 거리측정기")             │   │
│  └──────────┬──────────────────────────────────────────┘   │
│             ↓                                                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 2. AI 모델 실행                                        │   │
│  │    outputs = model(**inputs)                         │   │
│  │    probs = softmax(outputs.logits)                   │   │
│  └──────────┬──────────────────────────────────────────┘   │
│             ↓                                                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 3. 결과 생성                                           │   │
│  │    return {                                          │   │
│  │      "isStrategic": false,                          │   │
│  │      "confidence": 60.3,                            │   │
│  │      "eccn": "N/A"                                  │   │
│  │    }                                                 │   │
│  └──────────┬──────────────────────────────────────────┘   │
└─────────────┼───────────────────────────────────────────────┘
              │
              │ HTTP 200 OK
              │ {"isStrategic": false, "confidence": 60.3, ...}
              ↓
┌─────────────────────────────────────────────────────────────┐
│                    프론트엔드 (React)                          │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ PredictionResult.tsx                                 │   │
│  │  - 결과 받아서 화면에 표시                              │   │
│  │  - "비전략물자 (신뢰도 60.3%)"                          │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

### 🎬 실행 순서 (단계별)

#### 1단계: 백엔드 시작
```bash
cd C:\Users\user-\Desktop\ECHelper\backend
python -m uvicorn app:app --host 0.0.0.0 --port 8000 --reload
```

**일어나는 일:**
```python
# 1. FastAPI 앱 초기화
app = FastAPI()

# 2. CORS 설정 (프론트엔드 접근 허용)
app.add_middleware(CORSMiddleware, allow_origins=["http://localhost:5173"])

# 3. KoBERT 모델 로드 (10-20초 소요)
print("Loading KoBERT model...")
model = AutoModelForSequenceClassification.from_pretrained("../models/kobert-strategic-final")
tokenizer = AutoTokenizer.from_pretrained("../models/kobert-strategic-final")
print("Model loaded successfully!")

# 4. 서버 시작
# INFO: Uvicorn running on http://0.0.0.0:8000
```

#### 2단계: 프론트엔드 시작
```bash
cd C:\Users\user-\Desktop\ECHelper\frontend
npm run dev
```

**일어나는 일:**
```javascript
// 1. Vite 개발 서버 시작
// 2. React 앱 빌드
// 3. 브라우저 자동 열림
// ➜  Local:   http://localhost:5173/
```

#### 3단계: 사용자 상호작용

**사용자:**
1. 브라우저에서 `http://localhost:5173` 접속
2. Prediction 페이지 이동
3. "레이저 거리측정기" 입력
4. "예측 및 유사이력 검색" 버튼 클릭

**프론트엔드:**
```typescript
// PredictionPage.tsx
const handlePredict = async (formData) => {
  const queryText = `${formData.title} ${formData.description}`;

  // API 호출
  const result = await predictStrategicItem(queryText);

  // 상태 업데이트
  setPredictionResult(result);
};

// kobertPrediction.ts
export async function predictStrategicItem(text: string) {
  const response = await fetch('http://localhost:8000/predict', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ text })
  });

  return await response.json();
}
```

**백엔드:**
```python
# app.py
@app.post("/predict")
def predict(request: PredictRequest):
    # 1. 토크나이징
    inputs = tokenizer(
        request.text,
        return_tensors="pt",
        max_length=128,
        padding="max_length",
        truncation=True
    )

    # 2. 예측
    with torch.no_grad():
        model_inputs = {
            'input_ids': inputs['input_ids'],
            'attention_mask': inputs['attention_mask']
        }
        outputs = model(**model_inputs)
        logits = outputs.logits

        # Softmax
        probs = F.softmax(logits, dim=1)[0]
        prob_non_strategic = probs[0].item()
        prob_strategic = probs[1].item()

    # 3. 결과 반환
    is_strategic = prob_strategic > 0.5
    confidence = prob_strategic if is_strategic else prob_non_strategic

    return {
        "isStrategic": is_strategic,
        "confidence": confidence * 100,
        "eccn": "N/A" if not is_strategic else "0A001",
        "classType": "N/A" if not is_strategic else "E1",
        "explanation": f"비전략물자 (신뢰도: {confidence*100:.1f}%)"
    }
```

**프론트엔드 (결과 표시):**
```typescript
// PredictionResult.tsx
<Card title="예측 결과">
  <Tag color={result.isStrategic ? 'red' : 'green'}>
    {result.isStrategic ? '전략물자' : '비전략물자'}
  </Tag>

  <Progress percent={result.confidence} />

  <Descriptions>
    <Descriptions.Item label="ECCN">{result.eccn}</Descriptions.Item>
    <Descriptions.Item label="설명">{result.explanation}</Descriptions.Item>
  </Descriptions>
</Card>
```

### 🔑 핵심 파일 상세 설명

#### 1. `backend/app.py` (백엔드 메인)

**역할:** API 서버, AI 모델 실행

**주요 기능:**
```python
# 1. 모델 로드 (서버 시작 시 1번만)
model = AutoModelForSequenceClassification.from_pretrained("../models/kobert-strategic-final")
tokenizer = AutoTokenizer.from_pretrained("../models/kobert-strategic-final")

# 2. API 엔드포인트 정의
@app.post("/predict")  # POST http://localhost:8000/predict
def predict(request: PredictRequest):
    # 예측 로직
    pass

@app.get("/health")    # GET http://localhost:8000/health
def health():
    return {"status": "ok"}
```

**왜 FastAPI?**
- 빠른 성능 (Node.js와 비슷)
- 자동 API 문서 (`/docs`)
- 타입 검사 (Pydantic)

#### 2. `frontend/src/services/kobertPrediction.ts` (API 클라이언트)

**역할:** 백엔드 API 호출

**전체 코드:**
```typescript
const API_URL = 'http://localhost:8000';

export async function predictStrategicItem(text: string) {
  try {
    const response = await fetch(`${API_URL}/predict`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text })
    });

    if (!response.ok) {
      throw new Error(`API request failed: ${response.statusText}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Prediction error:', error);
    return {
      isStrategic: false,
      confidence: 0,
      eccn: 'Error',
      classType: 'Error',
      explanation: `백엔드 API 호출 중 오류 발생: ${error}`
    };
  }
}
```

**왜 이렇게?**
- 에러 처리 포함
- 타입 안전
- 재사용 가능

#### 3. `frontend/src/pages/PredictionPage.tsx` (메인 페이지)

**역할:** 사용자 인터페이스, 데이터 흐름 조정

**주요 로직:**
```typescript
const PredictionPage: React.FC = () => {
  // 상태 관리
  const [predictionResult, setPredictionResult] = useState<any>(null);
  const [similarCases, setSimilarCases] = useState<any[]>([]);
  const [allData, setAllData] = useState<any[]>([]);

  // 데이터 로드 (페이지 로딩 시)
  useEffect(() => {
    loadData();
  }, []);

  // 예측 요청 처리
  const handlePredict = async (formData: any) => {
    // 1. KoBERT 예측
    const result = await predictStrategicItem(queryText);
    setPredictionResult(result);

    // 2. 유사 사례 검색 (TF-IDF)
    const similarResults = findSimilarDocuments(queryText, allData, 5);
    setSimilarCases(similarResults);
  };

  return (
    <div>
      {/* 입력 폼 */}
      <PredictionForm onPredict={handlePredict} />

      {/* 예측 결과 */}
      <PredictionResult result={predictionResult} />

      {/* 유사 사례 */}
      <SimilarCasesList cases={similarCases} />
    </div>
  );
};
```

---

## 💡 자주 묻는 질문 (FAQ)

### Q1: 왜 localhost:8000과 localhost:5173 두 개를 써요?

**A:** 서로 다른 프로그램이기 때문입니다.

```
localhost:8000  → Python (FastAPI) 서버
localhost:5173  → JavaScript (Vite) 서버

마치 Word와 Excel을 동시에 켜는 것과 비슷
```

### Q2: 백엔드 없이 프론트엔드만 실행하면?

**A:** 화면은 나오지만 예측이 안 됩니다.

```
프론트엔드만 실행:
✅ 버튼 보임
✅ 입력 가능
❌ 예측 버튼 클릭 → "백엔드 API 호출 오류"
```

### Q3: 프론트엔드 없이 백엔드만 실행하면?

**A:** API는 작동하지만 화면이 없습니다.

```
백엔드만 실행:
✅ http://localhost:8000/predict 접근 가능
✅ Postman/curl로 테스트 가능
❌ 브라우저 UI 없음

예시:
curl -X POST http://localhost:8000/predict \
  -H "Content-Type: application/json" \
  -d '{"text":"레이저 거리측정기"}'
```

### Q4: 왜 매번 두 개를 시작해야 하나요?

**A:** 개발 중에만 그렇습니다. 실제 배포 시에는:

```
개발 중:
- 수동으로 2개 시작
- 코드 수정하면서 테스트

배포 후:
- 자동으로 시작
- 항상 켜져 있음
- systemd/PM2 등이 관리
```

### Q5: 둘을 하나로 합칠 수 없나요?

**A:** 기술적으로 가능하지만 비추천:

```
Next.js SSR (하나로 합치기):
✅ 한 번에 시작
❌ 복잡도 증가
❌ 서버 비용 증가
❌ 확장성 제한

분리된 구조 (현재):
✅ 각각 독립적 확장
✅ 개발 편리
✅ 유지보수 쉬움
❌ 초기 설정 복잡
```

### Q6: 실제 서버에 올리려면?

**A:** 3단계 과정:

```
1단계: 백엔드 배포
- AWS EC2 인스턴스 생성
- Python 환경 설정
- uvicorn 서버 실행
- 도메인 연결 (api.echelper.com)

2단계: 프론트엔드 배포
- npm run build (정적 파일 생성)
- Netlify/Vercel 업로드
- 도메인 연결 (www.echelper.com)

3단계: 연결
- 프론트엔드에서 API_URL 변경
- http://localhost:8000 → https://api.echelper.com
```

### Q7: 개발 vs 배포의 차이는?

| 항목 | 개발 환경 | 배포 환경 |
|------|----------|----------|
| **백엔드 URL** | http://localhost:8000 | https://api.echelper.com |
| **프론트엔드 URL** | http://localhost:5173 | https://www.echelper.com |
| **시작 방법** | 수동 (터미널 2개) | 자동 (systemd) |
| **코드 변경** | 즉시 반영 (--reload) | 재배포 필요 |
| **접근** | 내 컴퓨터만 | 전 세계 |
| **HTTPS** | 불필요 | 필수 (보안) |

---

## 📚 더 알아보기

### 추천 학습 자료

#### 프론트엔드
- **React 공식 문서**: https://react.dev
- **TypeScript 핸드북**: https://www.typescriptlang.org/docs/
- **MDN Web Docs**: https://developer.mozilla.org

#### 백엔드
- **FastAPI 튜토리얼**: https://fastapi.tiangolo.com
- **Python 공식 문서**: https://docs.python.org
- **REST API 디자인**: https://restfulapi.net

#### 배포
- **AWS 시작하기**: https://aws.amazon.com/getting-started/
- **Netlify 문서**: https://docs.netlify.com
- **Docker 튜토리얼**: https://docs.docker.com/get-started/

### 실습 아이디어

1. **간단한 TODO 앱 만들기**
   - 프론트엔드: React로 입력창/목록
   - 백엔드: FastAPI로 저장/조회

2. **날씨 앱 만들기**
   - 프론트엔드: 도시 입력창
   - 백엔드: 외부 API 호출 → 결과 반환

3. **이미지 분류 앱**
   - 프론트엔드: 이미지 업로드
   - 백엔드: AI 모델로 분류

---

## 🎯 핵심 요약

### 1줄 요약
> **프론트엔드(화면) + 백엔드(AI 서버) = 완전한 웹 애플리케이션**

### 5가지 핵심

1. **프론트엔드**: 사용자가 보고 만지는 것 (HTML/CSS/JavaScript)
2. **백엔드**: 서버에서 실행되는 로직 (Python/AI 모델)
3. **분리 이유**: 보안, 성능, 기술 제약, 유지보수
4. **통신 방법**: HTTP API (JSON 주고받기)
5. **개발 vs 배포**: 지금은 내 컴퓨터, 나중엔 클라우드 서버

### 비유로 기억하기

```
레스토랑 = 웹 애플리케이션

홀 (프론트엔드)          주방 (백엔드)
- 메뉴판                - 요리사
- 주문받기              - 레시피 실행
- 음식 서빙             - 재료 관리
- 고객 응대             - 맛 보장

둘이 협력해야 레스토랑 운영!
```

---

## 📝 마치며

이 문서를 읽고 나면:

✅ 프론트엔드와 백엔드의 차이를 이해했다
✅ 왜 둘로 나누는지 알게 되었다
✅ HTTP API 통신 원리를 파악했다
✅ 개발 환경과 배포 환경의 차이를 알았다
✅ ECHelper 프로젝트 구조를 이해했다

**다음 단계:**
1. 직접 코드를 수정해보기
2. 새로운 API 엔드포인트 추가하기
3. UI 컴포넌트 커스터마이징하기
4. 배포 준비하기 (선택)

**질문이 있다면:**
- 이 문서에 메모 추가
- 코드에 주석 달기
- 구글 검색 활용
- 커뮤니티 질문

**행운을 빕니다!** 🚀

---

**작성일**: 2025-12-31
**버전**: 1.0
**프로젝트**: ECHelper (Export Control Helper)
